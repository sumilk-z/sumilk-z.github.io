<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="zhu">



    <meta name="description" content="这是一个个人博客">



<title>计算机网络笔记——TCP/IP UDP | zcblog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Zhu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">主页</a>
                
                    <a class="menu-item" href="/category">归档</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Zhu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">主页</a>
                
                    <a class="menu-item" href="/category">归档</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">计算机网络笔记——TCP/IP UDP</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">zhu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">三月 13, 2023&nbsp;&nbsp;13:00:19</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/basic/">basic</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h4 id="面向连接和无连接"><a href="#面向连接和无连接" class="headerlink" title="面向连接和无连接"></a>面向连接和无连接</h4><p>打电话就是面向连接的，需要接电话的人拿起电话，建立连接。</p>
<p>发邮件是无连接的，发送方只管发送，不管接收方如何处理，不管接收方是否存在，接收地址是否正确。</p>
<h4 id="电路交换和分组交换"><a href="#电路交换和分组交换" class="headerlink" title="电路交换和分组交换"></a>电路交换和分组交换</h4><p>电路交换是一种古老的网络通信方式，通信的时候需要建立连接，并且两端是独占这条线路的。</p>
<p>分组交换是现在的网络通信方式，将要发送的数据分组编号，所有的计算机可以一起发送数据，这条线路不是独占的。</p>
<p><strong>TCP/IP 协议就是分组交换通信方式。</strong></p>
<p>电路交换的效率更高，但是资源利用率会降低。</p>
<p>分组交换中，由分组交换机（路由器，缓存分组）连接通信线路。</p>
<h4 id="七层网络模型"><a href="#七层网络模型" class="headerlink" title="七层网络模型"></a>七层网络模型</h4><p>从下到上： <strong>物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。</strong></p>
<p>实际应用是四层模型： 应用层 传输层 网络层 和 链路层</p>
<p>下层为上层提供服务，上层接收下层传输的数据进行包装处理。</p>
<p><strong>传输层与网络层的关系</strong>： 网络层不能保证数据一定会发送到对端地址，需要传输层来进行保障，传输层负责处理数据丢失、顺序混乱等问题。</p>
<p>传输层负责提供“正确传输数据的处理”， 网络层负责提供“发送和接收数据”。</p>
<h4 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h4><p>传输速率又指带宽，指单位时间内传输的<strong>数据量</strong>有多少（单位bps，bits pre second)。 而不是信号流动的速度，在各种传输媒介中信号流动的速度是恒定的。</p>
<p>主机之间的实际传输速率被称作吞吐量，不仅衡量带宽，还衡量CPU处理能力、网络的拥堵程度等。</p>
<h4 id="网卡NIC"><a href="#网卡NIC" class="headerlink" title="网卡NIC"></a>网卡NIC</h4><p>也叫网络适配器，任何一台计算机连接网络时必须使用网卡。可以集成到计算机主板中，也可以单独插入扩展槽使用。</p>
<p>NIC : network information center.</p>
<p>一个路由器上可有有多个网卡，多个IP地址，一个端口对应一个IP地址。</p>
<h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><p>repeater ： <strong>物理层面上延长网络的设备</strong>。</p>
<p>由电缆传过来的电信号或者光信号经中继器的<strong>波形调整和放大</strong>再传给另一个电缆。</p>
<p>中继器还可以负责<strong>不同媒介之间的转接</strong>，例如将电信号转为光信号。</p>
<p>中继器不负责判断数据是否错误，不改变数据传输的速率。</p>
<h4 id="网桥-2层交换机"><a href="#网桥-2层交换机" class="headerlink" title="网桥/2层交换机"></a>网桥/2层交换机</h4><p>数据链路层中用来连接两个网络的设备。能够识别数据链路层中的数据帧，将其缓存再转发，丢弃错误的数据帧。</p>
<p>网桥根据物理地址进行转发。</p>
<h4 id="路由器-3层交换机"><a href="#路由器-3层交换机" class="headerlink" title="路由器/3层交换机"></a>路由器/3层交换机</h4><p>路由器是网络层面上连接两个网络，并对分组报文进行转发的设备。根据IP地址进行转发。</p>
<h4 id="4-7层交换机"><a href="#4-7层交换机" class="headerlink" title="4~7层交换机"></a>4~7层交换机</h4><p>指传输层以上的交换机；</p>
<p>例如对于一个URL地址，统一的访问入口，访问后会分发到后台多个服务器上，这些服务器的前端加一个负载均衡器，实际上就是一种交换机。</p>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p><strong>协议翻译和转发数据。</strong></p>
<p>负责将从传输层到应用层的数据进行转换和转发的设备。</p>
<p>例如：手机邮件和电脑邮件之间通过网关进行转换，因此可以互发。即使是应用的不同电子邮件的协议，也能互相发送邮件。</p>
<p><strong>代理服务器也是一种网关，叫做应用网关</strong>。有了代理服务器，客户端和服务器无需在网络上直接通信，而是从传输层到应用层对数据和访问进行各种控制和处理。 </p>
<p>  B，网关，本身不是一种设备，是一种概念，是一个局域网连接到外网的接口 </p>
<p>  C，集线器，可以认为是物理层的设备，实现数据的广播转发，在局域网内使用 </p>
<p>  D，网卡，可以认为是数据链路层的设备，对数据帧的处理，明显也是在局域网内</p>
<h4 id="应用层、表示层、会话层案例"><a href="#应用层、表示层、会话层案例" class="headerlink" title="应用层、表示层、会话层案例"></a>应用层、表示层、会话层案例</h4><ul>
<li><p><strong>www</strong></p>
<p>也就是网上冲浪。 HTTP协议属于应用层协议，而传输数据的主要格式是HTML，HTML属于表示层协议。</p>
</li>
<li><p><strong>电子邮件</strong></p>
<p>发送电子邮件的协议是SMTP（simple mail transfer protocol，简单邮件传输协议）——应用层协议。</p>
<p>起初，只能发送文本格式的电子邮件，现在通过MIME协议扩展后可以发送声音、图像等各种格式的信息——表示层协议。</p>
</li>
<li><p><strong>文件传输FTP</strong></p>
<p>FTP——应用层协议。</p>
<p>传输时可以用二进制格式或者文本格式——表示层协议。</p>
<p>传输时需要建立两个TCP连接：一个是发起传输请求的控制连接，另一个是发送数据的数据连接。这两种连接的控制管理属于——会话层协议。</p>
</li>
<li><p><strong>远程登陆TELNET SSH</strong></p>
</li>
<li><p><strong>网络管理SNMP</strong></p>
<p>simple network management protocol</p>
<p>可以对联网的设备（服务器，PC，路由器，交换机等）进行远程修改配置，检查是否正常运行。</p>
<p>SNMP可以让管理员及时检查 网络拥堵情况，及早发现故障。</p>
</li>
</ul>
<h4 id="发送邮件的过程"><a href="#发送邮件的过程" class="headerlink" title="发送邮件的过程"></a>发送邮件的过程</h4><p>用户启动应用程序，编辑邮件内容，填写收件人信箱地址。</p>
<ul>
<li><p>应用程序处理</p>
<p>用户编写邮件　——　应用层</p>
<p>应用程序首先进行编码处理。 —— 表示层协议</p>
<p>但是邮件不会立即发出，可能会一次发送多个邮件或者需要用户点击收信功能才发送。 ——会话层</p>
</li>
<li><p>建立TCP连接——传输层</p>
</li>
</ul>
<p>​    在需要发送的那一刻建立TCP连接，包含TCP首部，首部是<strong>源端口号</strong>（本机发送邮件的应用程序的端口）和<strong>目标端口号</strong>（对方主机接收邮件的应用程序的端口），还有序号、校验和等。</p>
<ul>
<li><p>IP —— 网络层</p>
<p>IP 将TCP首部和数据作为自己的数据，添加IP首部，包含<strong>源IP地址</strong>和<strong>目标IP地址</strong>，以及判断是TCP还是UDP的信息。</p>
</li>
<li><p>以太网 —— 数据链路层</p>
</li>
</ul>
<p>从IP传过来的IP数据包，加上以太网首部：<strong>接收端MAC地址，发送端MAC地址</strong>以及以太网类型标志。 —— ARP 协议解析得到MAC地址</p>
<p>以太网数据包通过物理层传输给接收端。　　</p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>MAC地址48bit,一般被烧写到NIC网卡的ROM中。 任何一个网卡的MAC地址都是唯一的。</p>
<p>MAC地址规范没有限定数据链路的类型，不论哪种数据链路的类型：以太网，无线LAN，蓝牙，FDDI，ATM（异步传输模式）， 都不会有相同的MAC地址。</p>
<h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h4><p>载波侦听多路复用/冲突检测</p>
<p>csma/ca 冲突避免， 这是无线通信所用的方法。</p>
<h4 id="共享介质型网络"><a href="#共享介质型网络" class="headerlink" title="共享介质型网络"></a>共享介质型网络</h4><p>以太网和FDDI就是共享介质型网络，设备之间使用同一个载波信道进行发送和接收，工作方式是<strong>半双工通信</strong>。 </p>
<p>对介质进行访问控制的方法有两种</p>
<p><strong>1.抢占式/争用式</strong></p>
<p>需要用到CSMA/CD</p>
<p>网络上没有数据流动，任何站点都可以发送数据</p>
<p>检测是否会发生冲突，如果会则放弃发送数据。</p>
<p>放弃发送之后，随机等待一段时间，重新检测重新发送。</p>
<p><strong>2.令牌传递方式</strong></p>
<p>只有获得令牌的才能发送数据，令牌是一种特殊的报文。</p>
<p>特点： 一定不会产生冲突，每个站都有平等循环获得令牌的机会。</p>
<p>缺点：数据链路的利用率不能达到100%</p>
<h4 id="非介质共享"><a href="#非介质共享" class="headerlink" title="非介质共享"></a>非介质共享</h4><p>网络中的每个站直连交换机，有特定的传输线路，一般是<strong>全双工的通信方式</strong>。</p>
<p>例如ATM，通过交换机构建网络，从而使计算机与交换机之间形成 一对一的连接。</p>
<p>致命弱点：如果交换机故障，与之相连的所有计算机都无法通信。</p>
<p>半双工：只能发送或者接收，不能同时发送，否则无法接收信息。</p>
<p>全双工：两端可以同时发送，同时接收。类似打电话，两端可以同时说话。   </p>
<h4 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h4><p>实际上是数据链路层的交换机，即2层交换机。三层交换机是路由器。</p>
<p>以太网交换机就是持有多个端口的<strong>网桥</strong>，负责存储转发数据链路层的数据帧。交换机中有一个转发表，记录了对应端口所连接的主机MAC地址。</p>
<p>转发表的建立是自学的过程：主机A通过端口1进入数据，主机B通过端口2进入数据，当主机A要发送数据给主机B的时候，转发表中有 A : 1, B :2这样的对应关系，就知道应该通过端口2转发给主机B。</p>
<p>交换机转发的两种方式</p>
<ul>
<li>存储转发：经过以太网数据帧末尾的FCS校验之后再转发</li>
<li>直接转发：只需要得知目标地址后立即转发，延迟短，但是可能会发送错误帧。</li>
</ul>
<h4 id="数据链路层细分"><a href="#数据链路层细分" class="headerlink" title="数据链路层细分"></a>数据链路层细分</h4><p>还可以细分为 MAC层和LLC层，即<strong>介质访问控制层和逻辑链路控制层</strong>。</p>
<p>前者根据数据链路所特有的首部信息进行控制，后者根据数据链路所共有的帧头信息进行控制。</p>
<h4 id="无线通信"><a href="#无线通信" class="headerlink" title="无线通信"></a>无线通信</h4><p>无线标准和应用</p>
<p>无线PAN（personal aera network） 蓝牙 距离10米</p>
<p>无线LAN （local area network） WIFI 100米</p>
<p>无线WAN（wide area network） 3G，4G，下一代移动通信网络，可实现长距离无线通信，通过基站。</p>
<p>无线通信在物理层也使用MAC地址， 介质访问控制上使用CSMA/CA  avoidance 冲突避免</p>
<p>物理层上使用电磁波或红外线</p>
<p>WIFI wireless fidelity 指高质量的无线LAN</p>
<p>音响Hi-Fi ： high fidelity 高保真，高重现</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层的主要组成是IP协议和ICMP协议。</p>
<p>ICMP： internet control message protocol</p>
<p>网络层的主要作用是： <strong>实现终端节点之间的通信</strong>，但是并不保证准确，有序的传输。</p>
<p>网络层IP协议的特点：</p>
<ul>
<li><p>无连接</p>
<p>每个分组的传输过程都是相互独立的</p>
</li>
<li><p>不可靠　　　</p>
<p>不能保证每个IP分组都能够正确的，不丢失和顺序地到达目的节点</p>
</li>
<li><p>IP协议是点-点地网络层通信协议</p>
<p>源主机-路由器，路由器-路由器， 路由器-目标主机 组成一个虚电路。</p>
</li>
</ul>
<h4 id="网络层与数据链路层之间的关系"><a href="#网络层与数据链路层之间的关系" class="headerlink" title="网络层与数据链路层之间的关系"></a>网络层与数据链路层之间的关系</h4><p>数据链路层为网络层提供服务。</p>
<p>数据链路层的功能是：<strong>提供直连两个设备之间的通信功能</strong></p>
<p>而网络层的功能是： 终端节点之间的通信，是没有直接连接的，是对数据链路层的进一步抽象和控制。</p>
<p>IP是实现多个数据链路之间通信的协议， IP是面向无连接的，如果需要面向连接，可请求上一层提供服务，例如TCP协议就是面向连接的。</p>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>IP地址由网络号和主机号组成，由子网掩码可以推算出网络号。</p>
<p>IP地址分为四类</p>
<p>A类地址：以0开头的IP地址，前八位是网络号标识，后面２４位是主机号标识。　范围从０.０.０.０　～　１２７.０.０.０</p>
<p>B类地址：以１０开头的地址，前１６位是网络号</p>
<p>C类地址：以１１０开头的地址，前２４位是网络号，后８位为主机标识，因此一个网段内可以容纳的主机地址上限为２５４个。</p>
<p>D类地址：以１１１０开头的地址，前３２位是网络号，没有主机号。常用于多播</p>
<p>特殊的IP地址：</p>
<p>全部为0的IP地址：表示对应的网络地址或者IP地址不可获知</p>
<p>全部为1的IP地址：表示广播地址。</p>
<p>１２７．０．０．１为回环地址，表示本机IP地址。</p>
<h4 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h4><p>将包发送给特定组内的所有主机　　</p>
<h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h4><p>TTL是路由器的跳数，而不是时间。目的是用来防止死循环。</p>
<p>TTL 生存时间——用来设定分组在网络中被最多转发分组的<strong>路由器跳数</strong>，避免由于路由器错误引起数据报文在网络中循环、无休止地流动，耗费网络资源。</p>
<p>生存时间TTL的初始值由源主机设置，经过一个路由器，它的值就减1。当生存时间TTL的值为0时，分组就被丢弃，并发送ICMP报文通知源主机。</p>
<h4 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h4><p>地址解析协议，是解析MAC地址的协议，由IP地址解析出下一跳的MAC地址。</p>
<p>当路由器收到待转发的数据包，送交下层的网络接口软件，网络接口软件用ARP协议将下一跳路由器的IP地址转换成硬件地址，并将此硬件地址放在数据链路层的MAC帧首部，然后根据这个硬件地址找到下一跳的路由器。</p>
<p>RARP协议：从已知的物理地址找到对应的IP地址的映射过程。　现在一般不用该协议。</p>
<p> ARP分组包括：请求分组和应答分组。　请求分组是广播的方式，而应答分组可以原路返回，是单播的方式。</p>
<blockquote>
<p>ARP 实际上是一种应用层协议，但是工作在网络层。</p>
</blockquote>
<h4 id="路由转发过程"><a href="#路由转发过程" class="headerlink" title="路由转发过程"></a>路由转发过程</h4><ul>
<li>从收到的分组的首部提取目的IP地址</li>
<li>和本网络的子网掩码逐位与，看是否和相应的网络地址相互匹配，如果匹配，则直接交付，否则间接交付</li>
<li>看路由表中是否有特定主机路由，如果有，分组转发给指明的下一跳路由器</li>
<li>和路由表中每一行子网掩码逐位与，看是否有对应的网络号，有，下一跳</li>
<li>是否有默认路由，有，下一跳</li>
<li>报告转发分组出错。</li>
</ul>
<blockquote>
<p>路由转发的过程有：0.转发到特定的IP地址 1.转发到对应的网络，交给下一个网络处理 2.转发给默认路由器 </p>
</blockquote>
<h4 id="为什么不直接使用硬件地址进行通信"><a href="#为什么不直接使用硬件地址进行通信" class="headerlink" title="为什么不直接使用硬件地址进行通信"></a>为什么不直接使用硬件地址进行通信</h4><p>全世界存在着各种网络，使用不同的硬件地址。要使这些<strong>异构网络</strong>互相通信必须进行非常复杂的硬件地址转换工作。</p>
<blockquote>
<p>通俗理解：网络的结构不同，使用硬件地址进行转换很麻烦，还需要再进行进一步的上层抽象。</p>
</blockquote>
<h4 id="IGP-RIP-OSPF"><a href="#IGP-RIP-OSPF" class="headerlink" title="IGP RIP　OSPF"></a>IGP RIP　OSPF</h4><p>IGP：内部网关协议，interior gateway protocol 一个自治系统内部的路由协议，例如RIP协议和OSPF协议</p>
<blockquote>
<p>RIP 和 OSPF是两种路由协议。</p>
</blockquote>
<p><strong>RIP协议</strong>：路由开放协议routing information protocol</p>
<p>​    <strong>RIP基于 向量-距离路由选择算法</strong>， RIP认为一个好的路由就是它通过的路由器的数目少，即距离短。</p>
<p>​    建立和收敛过程：路由器之间周期性的向相邻路由器通知自己的路由表信息，然后当前路由器根据相邻路由器信息得知到达该自治系统其他路由器的最短路径是什么。（最短路径为经过的路由器数量最少）。</p>
<p>​    RIP只会选择最短路径，即便存在一条低延迟的高速线路。</p>
<p><strong>RIP协议使用用户数据报UDP进行传送，因为速度快，更新快，收敛快</strong> RIP是一个应用层协议。</p>
<p><strong>OSPF</strong> 开放最短路劲优先协议 open shortest path first</p>
<p>​    dijstra算法计算得到最短路径，刚开始通过洪泛来告知信息。</p>
<blockquote>
<p>RIP 容易陷入局部最优，而OSPF是全局最优。各有优缺点，RIP的收敛速度更快。</p>
</blockquote>
<p>EGP: 外部网关协议，连接不同自治系统的路由器之间使用，以交换路由信息。</p>
<h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>Internet 控制报文协议，<strong>用于在IP主机、路由器之间传递控制消息</strong>，目标是提高IP数据报交付成功的机会。</p>
<p>应用举例：PING</p>
<p>packet internet groper</p>
<ul>
<li>ping用来测试两个主机之间的连通性</li>
<li>ping使用了ICMP回送请求与回送应答报文</li>
<li>ping是应用层直接使用网络层ICMP的例子，没有通过传输层的TCP或者UDP</li>
</ul>
<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p><strong>套接字是支持TCP/IP网络通信的基本操作单元</strong>，可以看作是不同主机之间的进程进行双向通信的端点。</p>
<p>实际上可以理解为应用层的抽象。和网络层的IP地址一样。套接字可以理解为应用层的节点（端点），其映射的实际上是主机的一个进程。</p>
<h4 id="TCP与UDP比较"><a href="#TCP与UDP比较" class="headerlink" title="TCP与UDP比较"></a>TCP与UDP比较</h4><p>•TCP协议是一种<strong>面向连接、面向字节流、可靠的</strong>传输协议，提供了确认、业务流管理、拥塞控制与丢失重传功能。</p>
<p>•UDP协议简单，只关注数据交付和提高数据传输的速度。</p>
<blockquote>
<p>TCP 面向连接，面向字节流，传输的是字节流，而且保证可靠传输。</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>特征</strong>/<strong>描述</strong></th>
<th><strong>TCP</strong></th>
<th><strong>UDP</strong></th>
</tr>
</thead>
<tbody><tr>
<td>与应用层的数据接口</td>
<td>基于<strong>字节流</strong>，应用层不需要规定特定的数据格式</td>
<td>基于<strong>报文</strong>，应用层需要将数据分成包来传送</td>
</tr>
<tr>
<td>可靠性与确认</td>
<td><strong>可靠</strong>报文传输，对所有的数据均要确认</td>
<td>不可靠，不需要对传输的数据确认，尽力而为地交付</td>
</tr>
<tr>
<td>重传</td>
<td><strong>自动重传</strong>丢失的数据</td>
<td>不负责检查是否丢失数据和重传</td>
</tr>
<tr>
<td>开销</td>
<td>低，但高于UDP</td>
<td>很低</td>
</tr>
<tr>
<td>传输速率</td>
<td>高，但低于UDP</td>
<td>很高</td>
</tr>
<tr>
<td>适用数据量</td>
<td>从少量到几个GB的数据</td>
<td>从少量到几百个字节的数据</td>
</tr>
<tr>
<td>适用的应用类型</td>
<td>对数据传输可靠性要求较高的应用，例如文件与报文传输</td>
<td>发送数量比较少、对数据传输可靠性要求较低的应用，<strong>例如IP电话、视频会议</strong>、<strong>多播与广播</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>FTP 协议，文件传输是TCP。</p>
<p>ARP地址解析，或者路由协议都是用的UDP，以及视频传输等都是用的UDP协议。</p>
</blockquote>
<p>UDP协议的主要特点：</p>
<ul>
<li><p>UDP是一种无连接的、不可靠的运输层协议；</p>
</li>
<li><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，<strong>即端口的功能和差错检测的功能</strong>；</p>
</li>
<li><p>UDP是一种面向报文的运输层协议。</p>
</li>
</ul>
<p><strong>TCP协议的主要特点</strong></p>
<ul>
<li><p>TCP是一种面向连接的、可靠的运输层协议；</p>
</li>
<li><p>TCP协议建立在不可靠的网络层IP协议之上，IP不能提供任何可靠性机制，TCP的可靠性完全由自己实现；</p>
</li>
<li><p>TCP提供可靠交付服务，通过TCP连接传输的数据，<strong>无差错、不丢失、不重复，按序</strong>到达。</p>
</li>
<li><p><strong>TCP提供的是全双工服务</strong>.</p>
</li>
<li><p><strong>TCP连接是虚连接</strong>，即逻辑连接，不是物理连接（虚电路）</p>
</li>
</ul>
<p>•流（stream）相当于一个管道，从一端放入什么内容，从另一端可以照原样取出什么内容，它描述了一个不出现丢失、重复和乱序的数据传输过程；</p>
<p>•TCP在传输过程中将应用程序提交的数据看成是一连串的、无结构的字节流；</p>
<p>•TCP允许通信双方的应用程序在任何时候都可以发送数据；</p>
<p>•通信的双方都设置有发送和接收缓冲区；</p>
<p>•应用程序将要发送的数据字节提交给发送缓冲区，数据字节的实际发送过程由TCP协议来控制；</p>
<p>•接收端接收到数据字节之后也存放到接收缓冲区，高层应用程序在合适的时间到缓冲区中读取数据。</p>
<p>•TCP是一种可靠的传输服务协议，它使用确认机制检查数据是否安全和完整地到达，并且提供流量控制和拥塞控制功能；</p>
<p>TCP支持可靠数据通信的关键是对发送和接收的数据进行跟踪、确认与重传</p>
<h4 id="TCP连接建立与释放"><a href="#TCP连接建立与释放" class="headerlink" title="TCP连接建立与释放"></a>TCP连接建立与释放</h4><p><strong>建立连接阶段</strong>：三次握手  <strong>数据传输阶段</strong> <strong>连接释放阶段</strong>：四次握手</p>
<p>参考——<a target="_blank" rel="noopener" href="https://blog.csdn.net/WGDSXJJ/article/details/110928705">TCP连接建立过程</a></p>
<p>三次握手</p>
<ul>
<li>客户端向服务器发出连接请求报文，报头中的同步位SYN设置为1，并选择序号SEQ = x, 报文段不携带数据，但是要消耗一个序号。　<strong>SYN_SEND状态</strong><ul>
<li>连接请求报文的序号是随机产生的，但是不能为0，原因是<ul>
<li>增加安全性，避免被攻击者猜测到，被第三方伪造的报文RESET</li>
<li>避免因为TCP连接非正常断开而引起的混乱，如果在连接突然中断时，有一个或者两个进程同时等待对方的确认回答，这个时候有一个新连接的序号也是从0开始，那么接收进程就可能认为是对方重传的报文，造成链接过程错误。</li>
</ul>
</li>
</ul>
</li>
<li>服务器收到连接请求报文后，如果同意连接则发回确认，确认报文中SYN=1， ACK=1， 确认号为x+1，自己选择的序号为y（为了标识这个包），同样不携带数据，但是消耗一个序号。 <strong>SYN_RECV状态</strong></li>
<li>客户端收到服务端的确认报文之后，再次发送确认报文，其中ACK=1， 确认号为y+1. 客户端通知上层应用进程连接已经建立，可以进行数据传输了。 <strong>ESTABLISHED</strong></li>
<li>服务端接收到客户端的确认报文之后也通知上层应用进程：TCP连接已经建立 <strong>ESTABLISHED</strong></li>
</ul>
<blockquote>
<p>双方经历的状态 SYN_SEND  SYN_RECV  ESTABLISHED</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190122094332584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbjk2Mjc5MjUwMQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>为什么是三次？</strong></p>
<ol>
<li>长江长江，我是黄河，你能听见吗？</li>
<li>黄河黄河，我是长江，我能听见你说话，你能听见我说话吗</li>
<li>长江长江，我能听见你说话</li>
</ol>
<p>以上三步，打电话时，少了哪句都不行，如果没有以上三次对话，可能就会有对方听不见我说话的风险。但为什么是只对话三次，对话四次行不行，当然可以，对话一万次也行，只是，理论上三次是最小对话次数，因为三次对方中，有两次确认，双方都互相确认了对方已经能听到我说话了，虽然后续通话过程中仍有中断的风险，但为了节省确认成本，就只采用三次对话</p>
<p>四次挥手</p>
<p>数据传输结束后，客户端与服务器都可以主动提出释放连接请求。</p>
<ul>
<li>客户端发送报文，不携带数据，FIN=1，seq=u</li>
<li>服务端发送确认报文，ack=u+1, seq = v,通知上层应用，从客户端到服务端的连接就断开了，TCP连接处于半关闭状态： 客户端不发送数据，但服务端还可以发送数据，且客户端仍然要准备接收数据。</li>
<li>如果服务端已经没有要发送给客户端的数据，则应用进程通知TCP释放连接。</li>
<li>服务端向客户端 FIN=1， ACK=1， seq=w, ack=u+1</li>
<li>客户端发送ACK=1， seq=u+1, ack=w+1, 等待2MSL之后，如果没有接收到任何消息，彻底断开连接</li>
<li>MSL：maximum segment lifetime 最长报文段寿命</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190122105243815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbjk2Mjc5MjUwMQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>A tcp三次握手客户端connect，会发送SYN，服务器端确认并发送SYN，客户端确认，进入ESTABLISHED状态，客户端调用close，发送FIN，进入FIN_WAIT1状态，服务器端确认，进入CLOSE_WAIT状态，客户端进入FIN_WAIT2状态，服务器端调用close，客户端进入TIME_WAIT状态</p>
<p>TCP协议设置了四种计时器</p>
<p><strong>重传计时器</strong>：超时重传</p>
<p><strong>持续计时器</strong> ：用来防止死锁的； 如果接收方发送0窗口通告，发送方停止发送，启动持续计时器，到时间之后发送一个窗口探测报文，探测是否为非零窗口通告丢失。</p>
<p><strong>保活计时器</strong>: 用来防止TCP连接处于长期空闲状态，通常设置为2小时。超过之后发送探测报文，没有回应则关闭连接。</p>
<p><strong>时间等待计时器</strong> TIME-WAIT timer ： 连接终止期间使用，半关闭状态时，通常设置为报文寿命的2倍。</p>
<p>CLOSED: 表示初始状态。 </p>
<p>LISTEN: 表示服务器端的某个SOCKET处于监听状态，可以接受连接。 </p>
<p>SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。 </p>
<p>SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。</p>
<p>SYN_SENT状态表示客户端已发送SYN报文。</p>
<p> ESTABLISHED：表示连接已经建立。 </p>
<p>FIN_WAIT_1: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。</p>
<p>而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。 </p>
<p>FIN_WAIT_2：FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，还有数据需要传送，稍后再关闭连接。 </p>
<p>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。</p>
<p>如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 </p>
<p>CLOSING: 属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。 </p>
<p>CLOSE_WAIT: 这种状态的含义表示在等待关闭。当对方close一个SOCKET后发送FIN报文，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。 </p>
<p>LAST_ACK: 它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>•接收端根据自己的接收能力给出一个合适的接收窗口（rwnd），写入TCP报头，通知发送端。又称为通知窗口（advertised windows）；</p>
<p>发送方在确定发送窗口时，应该取“通知窗口”和“拥塞窗口 ”中的较小值</p>
<p>•发送方维持一个拥塞窗口 cwnd 状态变量，大小取决于网络的拥塞程度，并且动态变化。</p>
<p>•发送方控制拥塞窗口的原则：</p>
<p>•没有拥塞，窗口增大；出现拥塞，窗口减小。 </p>
<p><strong>•如何发现网络出现拥塞？</strong></p>
<p>•路由器是否丢弃分组！（网络中传输的分组总量较大，超过路由器的接收能力。）</p>
<p>•发送方根据超时来预测网络出现拥塞，接收方可以通过发送重复确认来报告拥塞。</p>
<p>•快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。 </p>
<p>•发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必等超时现象的出现。 </p>
<h4 id="C-S模式和P2P模式"><a href="#C-S模式和P2P模式" class="headerlink" title="C/S模式和P2P模式"></a>C/S模式和P2P模式</h4><p>•传统互联网中的C/S模式，信息资源的共享以服务器为中心，服务提供者与服务使用者之间的界限清晰；</p>
<p>•P2P网络中的计算机处于对等地位，不依赖于专用的集中式服务器，淡化了服务提供者与使用者之间的界限，可以身兼双重身份。</p>
<p>P2P网络并不是一种新的网络结构，而是一种新的网络应用模式。</p>
<p><strong>目前大量使用的P2P即时通信程序，如QQ也采用P2P与C/S的混合模式</strong></p>
<p><img src="/assets/image-20230210205246075.png" alt="image-20230210205246075"></p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>•DNS(Domain　Name System)作用是将主机域名转换为IP地址，它使得各种互联网应用成为可能，是互联网所有应用层协议的基础，提供核心服务<br>DNS 是一种应用层协议，但与其它web等协议不同，它不直接与用户打交道。<br>大型的互连网络中需要有一个全局的地址系统，它能够给每一台主机或路由器的网络连接分配一个全局惟一的地址；<br>网络中的每一个主机或路由器至少有一个IP地址；在Internet中不允许有两个设备具有同样的IP地址；<br>如果一台主机或路由器连接到两个或多个物理网络，那么它可以拥有两个或多个IP地址。</p>
<p>，/etc/hosts，主机名和ip配置文件。hosts—The static table lookup for host name(主机名查询静态表)<br>linux 的/etc/hosts是配置ip地址和其对应主机名的文件，这里可以记录本机的或其他主机的ip及其对应主机名。不同的linux版本，这个配置文件也可能不同。比如Debian的对应文件时/etc/hostname。</p>
<p>Nslookup(name server lookup)( 域名查询)：是一个用于查询 Internet 域名信息或诊断DNS 服务器问题的工具</p>
<p>将域名转换为对应IP地址的过程称为域名解析(name resolution)，完成该功能的是“域名解析器”软件。<br>域名解析方法：<br><strong>递归解析（recursive resolution）</strong><br><strong>迭代解析（iterative resolution）</strong><br>主机向本地域名服务器的查询一般都是采用递归查询。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文本地域名服务器向根域名服务器的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</p>
<p><img src="/assets/image-20230210210346339.png" alt="image-20230210210346339"></p>
<h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><p>超文本传输协议 (Hypertext transfer protocol，HTTP) 是一种详细规定了浏览器和web服务器之间互相通信的规则，通过Internet传送web文档的数据传送协议。</p>
<p>HTTP1.1，用于 http:// 网址</p>
<p>HTTP2.0，用于 https:// 网址，目的是在开放互联网上增加使用加密技术，以提供强有力的保护去遏制主动攻击。</p>
<p>HTTP 有两类报文：</p>
<ul>
<li><p><strong>请求报文</strong>——从客户向服务器发送请求报文。</p>
</li>
<li><p><strong>响应报文</strong>——从服务器到客户的回答</p>
</li>
</ul>
<p>HTTP协议支持：</p>
<p><strong>非持续连接（nonpersistent connection）HTTP/1.0使用</strong></p>
<p>•对每次请求/响应都要建立一次TCP连接。</p>
<p><strong>持续连接（persistent connection）HTTP/1.1使用</strong></p>
<p>•服务器在发出响应后保持该TCP连接，在相同的客户进程端与服务器端之间的后续报文都通过该连接传送。</p>
<p>非持续连接</p>
<p>•客户进程在80端口发起一次与服务器的TCP连接;</p>
<p>•客户进程在TCP连接上发送HTTP请求报文，对象路径netlab/picture.gif;</p>
<p>•服务器在TCP连接上接收HTTP请求报文，将对象封装进HTTP应答报文，发送到客户进程;</p>
<p>•服务器进程通知TCP协议<strong>断开此次TCP连接;</strong></p>
<p>•客户程序接收到应答报文后，通知TCP协议断开此次TCP连接;</p>
<p>•客户程序对于每个gif文件的引用重复一次以上过程。</p>
<p>持续连接</p>
<p>•一个Web服务器中的一个Web页的多个对象，或者多个Web页可以通过一个持续的TCP连接来传送;</p>
<p>•服务器进程在接收到客户进程的退出请求或超时时才关闭该连接。</p>
<p>方法（操作）          意义</p>
<p>OPTION      请求一些选项的信息</p>
<p>GET         请求读取由 URL所标志的信息</p>
<p>HEAD      请求读取由 URL所标志的信息的首部</p>
<p>POST     给服务器添加信息（例如，注释）</p>
<p>PUT      在指明的 URL下存储一个文档</p>
<p>DELETE   删除指明的 URL所标志的资源</p>
<p>TRACE      用来进行环回测试的请求报文</p>
<p>CONNECT  用于代理服务器</p>
<table>
<thead>
<tr>
<th><strong>代码</strong></th>
<th><strong>短语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>continue</td>
<td>请求的开始部分已被接受，客户可以继续请求</td>
</tr>
<tr>
<td>101</td>
<td>switching</td>
<td>服务器同意客户请求，切换到更新报头中定义的协议</td>
</tr>
<tr>
<td>200</td>
<td>ok</td>
<td>请求成功</td>
</tr>
<tr>
<td>201</td>
<td>created</td>
<td>新的URL被创建</td>
</tr>
<tr>
<td>202</td>
<td>accepted</td>
<td>请求被接受，但还没有马上起作用</td>
</tr>
<tr>
<td>204</td>
<td>no accepted</td>
<td>报文中没有内容</td>
</tr>
<tr>
<td>301</td>
<td>Multiple choices</td>
<td>所请求的URL指向多个资源</td>
</tr>
<tr>
<td>302</td>
<td>moved permanently</td>
<td>服务器已经不再使用所请求的URL</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>304</th>
<th>Moved temporarily</th>
<th>所请求的URL已暂时地移走</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>bad request</td>
<td>在请求中有语法错误</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求缺乏适当的授权</td>
</tr>
<tr>
<td>403</td>
<td>forbidden</td>
<td>服务被拒绝</td>
</tr>
<tr>
<td>404</td>
<td>not found</td>
<td>文档未找到</td>
</tr>
<tr>
<td>405</td>
<td>Method not allowed</td>
<td>URL不支持</td>
</tr>
<tr>
<td>406</td>
<td>not acceptable</td>
<td>所请求的格式不可接受</td>
</tr>
<tr>
<td>500</td>
<td>server error</td>
<td>服务器端出错</td>
</tr>
<tr>
<td>501</td>
<td>not implemented</td>
<td>所请求的动作不能完成</td>
</tr>
<tr>
<td>503</td>
<td>service unavailable</td>
<td>服务器暂时不可用，但以后可能接受请求</td>
</tr>
</tbody></table>
<ul>
<li>301：moved permanently 资源永久移动</li>
<li>302：moved temporarily 资源临时移动</li>
</ul>
<h4 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h4><p>•万维网站点使用 Cookie 来跟踪用户。</p>
<p>•Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。</p>
<p>•使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。 </p>
<p>•Cookie技术由4个部分组成</p>
<p>（1）在HTTP响应报文中有一个cookie首部行；</p>
<p>（2）在HTTP请求报文中有一个cookie首部行；</p>
<p>（3）在用户端系统中保留有一个cookie文件，由用户的浏览器管理；</p>
<p>（4）在Web站点有一个后端数据库。</p>
<h4 id="代理服务器（高速缓存）"><a href="#代理服务器（高速缓存）" class="headerlink" title="代理服务器（高速缓存）"></a>代理服务器（高速缓存）</h4><p>•代理服务器(proxy server)又称为万维网高速缓存(Web cache)，它代表浏览器发出 HTTP 请求。</p>
<p>•万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中。</p>
<p>•当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按 URL 的地址再去因特网访问该资源。 </p>
<p>(1) 浏览器访问因特网的服务器时，要先与校园网的高速缓存建立 TCP 连接，并向高速缓存发出 HTTP 请求报文。</p>
<p>(2) 若高速缓存已经存放了所请求的对象，则将此对象放入 HTTP 响应报文中返回给浏览器。</p>
<p>(3) 否则，高速缓存就代表发出请求的用户浏览器，与因特网上的源点服务器建立 TCP 连接，并发送 HTTP 请求报文</p>
<p>(4) 源点服务器将所请求的对象放在 HTTP 响应报文中返回给校园网的高速缓存。</p>
<p>(5) 高速缓存收到此对象后，先复制在其本地存储器中（为今后使用），然后再将该对象放在 HTTP 响应报文中，通过已建立的 TCP 连接，返回给请求该对象的浏览器。</p>
<h3 id="牛客网题目"><a href="#牛客网题目" class="headerlink" title="牛客网题目"></a>牛客网题目</h3><p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/4e8e739c23ac4eec92de00a24026f827">https://www.nowcoder.com/questionTerminal/4e8e739c23ac4eec92de00a24026f827</a>?<br>来源：牛客网</p>
<p>早期以太网采用的拓扑结构基本是总线型。总线型所需的电缆较少、价格便宜、管理成本高，不易隔离故障点、采用共享的访问机制，易造成网络拥塞。早期以太网多使用总线型的拓扑结构，采用同轴缆作为传输介质，连接简单，通常在小规模的网络中不需要专用的网络设备，但由于它存在的固有缺陷，<strong>已经逐渐被以集线器和交换机为核心的星型网络所代替</strong>。 </p>
<p>所有的互联网标准都是以RFC的形式在互联网上发表的。所有的RFC文档都可以从互联网上免费下载。并非所有的RFC文档都是互联网标准，只有很少的RFC文档最后变成了互联网标准</p>
<p><strong>（1）电路交换、分组交换、报文交换的区别</strong></p>
<p>答：电路交换需要建立一条专用的数据通信路径，这条路径上可能包含许多中间节点。这条通信路径在整个通信过程中将被独占，直到通信结束才会释放资源；报文交换以报文作为数据传输单位，携带有源地址和目的地址等信息；分组交换是将大的数据块分割成小的分组，并添加源地址、目的地址和分组编号等信息。</p>
<p><strong>（2）计算机网络提供有哪些服务</strong>（面向连接服务与无连接服务 、可靠服务和不可靠服务、有应答服务和无应答服务，要知道工作原理）。</p>
<p><strong>（3）ISO/OSI参考模型是什么？TCP/IP模型是什么？</strong></p>
<p>答：ISO/OSI参考模型是网络传输协议规范，一共有7层，分别为一个电脑从软件到它的硬件，从它的硬件到它的软件的传输。当软件发送一个网络数据包时，只要输入很简单的信息，然后要经过这些层，传输到硬件。传到硬件之后，由接收的电脑的相应的层来解读，这就是ISO/OSI参考模型；TCP/IP 模型就是互联网的协议，分为四个层次：应用层、传输层、网络互连层、主机到网络层（各层次的功能，包含的协议要去了解）。</p>
<p><strong>（4）端到端通信和点到点通信的区别</strong></p>
<p>答：端到端通信指的是在数据传输前，经过各种各样的交换设备，在两端设备问建立一条链路，就僚它们是直接相连的一样，链路建立后，发送端就可以发送数据，直至数据发送完毕，接收端确认接收成功；点到点通信指的是发送端把数据传给与它直接相连的设备，这台设备在合适的时候又把数据传给与之直接相连的下一台设备，通过一台一台直接相连的设备，把数据传到接收端。</p>
<p><strong>2.物理层</strong></p>
<p><strong>（1）同步请求和异步请求分别是什么意思？</strong></p>
<p>答：同步请求是指当浏览器向服务器发送同步请求时，服务处理同步请求的过程中，浏览器会处于等待的状态，服务器处理完请求把数据响应给浏览器并覆盖浏览器内存中原有的数据，浏览器——重新加载页面并展示服务器响应的数据；异步请求是指浏览器把请求交给代理对象，由代理对象向服务器发起请求，接收、解析服务器响应的数据，并把数据更新到浏览器指定的控件上。从而实现了页面数据的局部刷新。</p>
<p><strong>（2）物理层的几种复用</strong>（频分复用、时分复用、波分复用、码分复用，掌握每种复用的作用）</p>
<p><strong>3.数据链路层</strong></p>
<p><strong>（1）可靠传输机制有哪些？</strong></p>
<p>答：序列号、校验和、确认应答机制、超时重传、连接管理（三次握手四次挥手）、流量控制、拥塞控制。</p>
<p><strong>（2）流量控制的常见方式</strong>（停止-等待流量控制方式基本原理、滑动窗口流量控制方式基本原理、后退N帧协议、选择重传协议，掌握原理）</p>
<p><strong>（3）随机访问介质访问控制协议</strong>（ALOHA协议、CSMA/CD协议、CSMA协议、CSMA/CA协议，掌握原理）</p>
<p><strong>（4）HDLC协议是什么？</strong></p>
<p>答：HDLC是一种面向比特的链路层协议，使用点到点链路连接，中间没有任何第三个节点。</p>
<p><strong>4.网络层</strong></p>
<p><strong>（1）路由器的主要功能</strong>（路由选择、分组转发，掌握原理）</p>
<p><strong>（2）动态路由算法</strong>（距离向量路由算法、、链路状态路由算法，重要，掌握原理）</p>
<p><strong>（3）什么是IP地址？什么是MAC地址？</strong></p>
<p>答：IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异；MAC是地址物理地址，用来定义网络设备的位置，在OSI模型中，第三层网络层负责IP地址，第二层数据链路层则负责 MAC地址。</p>
<p><strong>（4）DHCP动态主机配置协议、ICMP网际控制报文协议</strong></p>
<p>5.传输层</p>
<p><strong>（1）传输层的功能</strong></p>
<p>答：传输层提供应用进程之间的逻辑通信，能够实现传送数据的复用和分用，传输层能够对收到的报文进行差错检测，并提供面向连接的TCP协议和无连接的UDP协议。</p>
<p><strong>（2）UDP协议的特点</strong></p>
<p>答：UDP是无连接的，即发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。UDP使用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表。UDP面向报文，发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP 层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</p>
<p><strong>（3）TCP协议</strong>（很重要，内容较多，小伙伴们自行百度）</p>
<p><strong>（4）拥塞控制的四种算法</strong>（慢开始算法、拥塞避免算法、快重传、快恢复，掌握算法原理）</p>
<p><strong>（5）为什么不采用“两次握手”建立连接？</strong></p>
<p>答：这是为了防止两次握手情况下已失效的连接请求报文段突然又传送到服务器而产生错误。</p>
<p><strong>6.应用层</strong></p>
<p><strong>（1）DNS域名解析协议是什么？</strong></p>
<p>答：域名解析协议是能够来将域名和IP地址相互映射，使人更方便地访问互联网的协议。</p>
<p><strong>（2）FTP文件传输协议是什么？</strong></p>
<p>答：FTP协议是基于TCP的传输，FTP采用双TCP连接方式，提供一种在服务器和客户机之间上传和下载文件的有效方式，支持授权与认证机制，提供目录列表功能。</p>
<p><strong>（3）SMTP简单邮件传输协议是什么？</strong></p>
<p>答：SMTP简单邮件传输协议是一种提供可靠且有效的电子邮件传输 的协议，它控制两个相互通信的SMTP 进程交换信息。有以下三个阶段，连接建立、 邮件传送、连接释放。</p>
<p><strong>（4）HTTP超文本传输协议是什么？</strong></p>
<p>答：HTTP超文本传输协议是用于从万维网服务器传输超文本到本地浏览器的传送协议，它一个无状态的请求/响应协议，是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准，HTTP超文本传输协议基于TCP/IP通信协议来传递数据。</p>
<h3 id="面试题目汇总1"><a href="#面试题目汇总1" class="headerlink" title="面试题目汇总1"></a>面试题目汇总1</h3><h4 id="HTTP长连接和短链接的区别"><a href="#HTTP长连接和短链接的区别" class="headerlink" title="HTTP长连接和短链接的区别"></a>HTTP长连接和短链接的区别</h4><h4 id="什么是TCP粘包-拆包，发生的原因是什么"><a href="#什么是TCP粘包-拆包，发生的原因是什么" class="headerlink" title="什么是TCP粘包/拆包，发生的原因是什么"></a>什么是TCP粘包/拆包，发生的原因是什么</h4><h4 id="服务器存在缓存的原因，如何实现"><a href="#服务器存在缓存的原因，如何实现" class="headerlink" title="服务器存在缓存的原因，如何实现"></a>服务器存在缓存的原因，如何实现</h4><p>实现：服务器方面，客户端方面。</p>
<p>原因：缓解服务器压力</p>
<h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><p>post请求产生两个TCP数据包</p>
<p>有些文章中提到，POST 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。</p>
<p>HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。</p>
<p>所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。</p>
<p>GET幂等性，POST非幂等性，不要用GET请求做增删改等会改变服务器内容的操作。</p>
<h4 id="一个TCP连接可以对应几个HTTP请求"><a href="#一个TCP连接可以对应几个HTTP请求" class="headerlink" title="一个TCP连接可以对应几个HTTP请求"></a>一个TCP连接可以对应几个HTTP请求</h4><h4 id="一个TCP连接中HTTP请求可以一起发送么"><a href="#一个TCP连接中HTTP请求可以一起发送么" class="headerlink" title="一个TCP连接中HTTP请求可以一起发送么"></a>一个TCP连接中HTTP请求可以一起发送么</h4><p>那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：</p>
<ul>
<li>维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。</li>
<li>和服务器建立多个 TCP 连接</li>
</ul>
<h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><p>1、HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>2、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<h4 id="什么是SSL-TLS"><a href="#什么是SSL-TLS" class="headerlink" title="什么是SSL/TLS"></a>什么是SSL/TLS</h4><p>SSL代表安全套接字层。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。 身份验证 ， 加密Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>
<p>SSL/TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；加密和解密都使用同一个密钥的</p>
<p>对称加密：优点在于加密、解密效率通常比较高 ，HTTPS 是基于非对称加密的， 公钥是公开的，</p>
<h4 id="HTTP-中-缓存的私有和公有字段"><a href="#HTTP-中-缓存的私有和公有字段" class="headerlink" title="HTTP 中 缓存的私有和公有字段"></a>HTTP 中 缓存的私有和公有字段</h4><p>Cache-Control : private / public </p>
<p>存储在用户浏览器中/存储在代理服务器中， 单独用户使用/多个用户使用</p>
<h4 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h4><p>客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认 没有彻底根治的办法，除非不使用TCP DDos 预防： 1）限制同时打开SYN半链接的数目 2）缩短SYN半链接的Time out 时间 3）关闭不必要的服务</p>
<h4 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h4><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li>
<li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li>
</ul>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常</p>
<blockquote>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在<strong>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</strong>，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源</p>
</blockquote>
<h4 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><p><strong>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的</strong>，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，<strong>通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密</strong>，<strong>接收方收到通信内容后使用私有密钥解密</strong>。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢。</li>
</ul>
<h3 id="面试题汇总2"><a href="#面试题汇总2" class="headerlink" title="面试题汇总2"></a>面试题汇总2</h3><h5 id="为什么需要三次握手？两次不行？"><a href="#为什么需要三次握手？两次不行？" class="headerlink" title="为什么需要三次握手？两次不行？"></a>为什么需要三次握手？两次不行？</h5><h5 id="为什么需要四次挥手？三次不行？"><a href="#为什么需要四次挥手？三次不行？" class="headerlink" title="为什么需要四次挥手？三次不行？"></a>为什么需要四次挥手？三次不行？</h5><h5 id="TCP-与-UDP-有哪些区别？各自应用场景？"><a href="#TCP-与-UDP-有哪些区别？各自应用场景？" class="headerlink" title="TCP 与 UDP 有哪些区别？各自应用场景？"></a>TCP 与 UDP 有哪些区别？各自应用场景？</h5><h5 id="HTTP1-0，1-1，2-0-的版本区别"><a href="#HTTP1-0，1-1，2-0-的版本区别" class="headerlink" title="HTTP1.0，1.1，2.0 的版本区别"></a>HTTP1.0，1.1，2.0 的版本区别</h5><h5 id="POST-和-GET-有哪些区别？各自应用场景？"><a href="#POST-和-GET-有哪些区别？各自应用场景？" class="headerlink" title="POST 和 GET 有哪些区别？各自应用场景？"></a>POST 和 GET 有哪些区别？各自应用场景？</h5><h5 id="HTTP-哪些常用的状态码及使用场景？"><a href="#HTTP-哪些常用的状态码及使用场景？" class="headerlink" title="HTTP 哪些常用的状态码及使用场景？"></a>HTTP 哪些常用的状态码及使用场景？</h5><p>200 404 403 500 301 302</p>
<h5 id="HTTP-状态码-301-和-302-的区别，都有哪些用途？"><a href="#HTTP-状态码-301-和-302-的区别，都有哪些用途？" class="headerlink" title="HTTP 状态码 301 和 302 的区别，都有哪些用途？"></a>HTTP 状态码 301 和 302 的区别，都有哪些用途？</h5><p>301 永久性转移</p>
<p>302 暂时性重定向</p>
<h5 id="在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？"><a href="#在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？" class="headerlink" title="在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？"></a>在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</h5><h5 id="HTTP-如何实现长连接？在什么时候会超时？"><a href="#HTTP-如何实现长连接？在什么时候会超时？" class="headerlink" title="HTTP 如何实现长连接？在什么时候会超时？"></a>HTTP 如何实现长连接？在什么时候会超时？</h5><h5 id="TCP-如何保证有效传输及拥塞控制原理"><a href="#TCP-如何保证有效传输及拥塞控制原理" class="headerlink" title="TCP 如何保证有效传输及拥塞控制原理"></a>TCP 如何保证有效传输及拥塞控制原理</h5><h5 id="IP-地址有哪些分类？"><a href="#IP-地址有哪些分类？" class="headerlink" title="IP 地址有哪些分类？"></a>IP 地址有哪些分类？</h5><h5 id="GET-请求中-URL-编码的意义"><a href="#GET-请求中-URL-编码的意义" class="headerlink" title="GET 请求中 URL 编码的意义"></a>GET 请求中 URL 编码的意义</h5><h5 id="什么是-SQL-注入？举个例子？"><a href="#什么是-SQL-注入？举个例子？" class="headerlink" title="什么是 SQL 注入？举个例子？"></a>什么是 SQL 注入？举个例子？</h5><p>在用户输入的字符串中添加SQL语句。</p>
<h5 id="谈一谈-XSS-攻击，举个例子？"><a href="#谈一谈-XSS-攻击，举个例子？" class="headerlink" title="谈一谈 XSS 攻击，举个例子？"></a>谈一谈 XSS 攻击，举个例子？</h5><h5 id="讲一下网络五层模型，每一层的职责？"><a href="#讲一下网络五层模型，每一层的职责？" class="headerlink" title="讲一下网络五层模型，每一层的职责？"></a>讲一下网络五层模型，每一层的职责？</h5><h5 id="简单说下-HTTPS-和-HTTP-的区别"><a href="#简单说下-HTTPS-和-HTTP-的区别" class="headerlink" title="简单说下 HTTPS 和 HTTP 的区别"></a>简单说下 HTTPS 和 HTTP 的区别</h5><h5 id="对称加密与非对称加密的区别"><a href="#对称加密与非对称加密的区别" class="headerlink" title="对称加密与非对称加密的区别"></a>对称加密与非对称加密的区别</h5><h5 id="简单说下每一层对应的网络协议有哪些？"><a href="#简单说下每一层对应的网络协议有哪些？" class="headerlink" title="简单说下每一层对应的网络协议有哪些？"></a>简单说下每一层对应的网络协议有哪些？</h5><h5 id="ARP-协议的工作原理？"><a href="#ARP-协议的工作原理？" class="headerlink" title="ARP 协议的工作原理？"></a>ARP 协议的工作原理？</h5><h5 id="TCP-的主要特点是什么？"><a href="#TCP-的主要特点是什么？" class="headerlink" title="TCP 的主要特点是什么？"></a>TCP 的主要特点是什么？</h5><h5 id="UDP-的主要特点是什么？"><a href="#UDP-的主要特点是什么？" class="headerlink" title="UDP 的主要特点是什么？"></a>UDP 的主要特点是什么？</h5><h5 id="TCP-和-UDP-分别对应的常见应用层协议有哪些？"><a href="#TCP-和-UDP-分别对应的常见应用层协议有哪些？" class="headerlink" title="TCP 和 UDP 分别对应的常见应用层协议有哪些？"></a>TCP 和 UDP 分别对应的常见应用层协议有哪些？</h5><h5 id="为什么-TIME-WAIT-状态必须等待-2MSL-的时间呢？"><a href="#为什么-TIME-WAIT-状态必须等待-2MSL-的时间呢？" class="headerlink" title="为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？"></a>为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？</h5><h5 id="保活计时器的作用？"><a href="#保活计时器的作用？" class="headerlink" title="保活计时器的作用？"></a>保活计时器的作用？</h5><h5 id="TCP-协议是如何保证可靠传输的？"><a href="#TCP-协议是如何保证可靠传输的？" class="headerlink" title="TCP 协议是如何保证可靠传输的？"></a>TCP 协议是如何保证可靠传输的？</h5><h5 id="谈谈你对停止等待协议的理解？"><a href="#谈谈你对停止等待协议的理解？" class="headerlink" title="谈谈你对停止等待协议的理解？"></a>谈谈你对停止等待协议的理解？</h5><h5 id="谈谈你对-ARQ-协议的理解？"><a href="#谈谈你对-ARQ-协议的理解？" class="headerlink" title="谈谈你对 ARQ 协议的理解？"></a>谈谈你对 ARQ 协议的理解？</h5><h5 id="谈谈你对滑动窗口的了解？"><a href="#谈谈你对滑动窗口的了解？" class="headerlink" title="谈谈你对滑动窗口的了解？"></a>谈谈你对滑动窗口的了解？</h5><h5 id="谈下你对流量控制的理解？"><a href="#谈下你对流量控制的理解？" class="headerlink" title="谈下你对流量控制的理解？"></a>谈下你对流量控制的理解？</h5><h5 id="谈下你对-TCP-拥塞控制的理解？使用了哪些算法？"><a href="#谈下你对-TCP-拥塞控制的理解？使用了哪些算法？" class="headerlink" title="谈下你对 TCP 拥塞控制的理解？使用了哪些算法？"></a>谈下你对 TCP 拥塞控制的理解？使用了哪些算法？</h5><h5 id="什么是粘包？"><a href="#什么是粘包？" class="headerlink" title="什么是粘包？"></a>什么是粘包？</h5><h5 id="TCP-黏包是怎么产生的？"><a href="#TCP-黏包是怎么产生的？" class="headerlink" title="TCP 黏包是怎么产生的？"></a>TCP 黏包是怎么产生的？</h5><h5 id="怎么解决拆包和粘包？"><a href="#怎么解决拆包和粘包？" class="headerlink" title="怎么解决拆包和粘包？"></a>怎么解决拆包和粘包？</h5><h5 id="forward-和-redirect-的区别？"><a href="#forward-和-redirect-的区别？" class="headerlink" title="forward 和 redirect 的区别？"></a>forward 和 redirect 的区别？</h5><h5 id="HTTP-方法有哪些？"><a href="#HTTP-方法有哪些？" class="headerlink" title="HTTP 方法有哪些？"></a>HTTP 方法有哪些？</h5><h5 id="在浏览器中输入-URL-地址到显示主页的过程？"><a href="#在浏览器中输入-URL-地址到显示主页的过程？" class="headerlink" title="在浏览器中输入 URL 地址到显示主页的过程？"></a>在浏览器中输入 URL 地址到显示主页的过程？</h5><h5 id="DNS-的解析过程？"><a href="#DNS-的解析过程？" class="headerlink" title="DNS 的解析过程？"></a>DNS 的解析过程？</h5><h5 id="谈谈你对域名缓存的了解？"><a href="#谈谈你对域名缓存的了解？" class="headerlink" title="谈谈你对域名缓存的了解？"></a>谈谈你对域名缓存的了解？</h5><h5 id="谈下你对-HTTP-长连接和短连接的理解？分别应用于哪些场景？"><a href="#谈下你对-HTTP-长连接和短连接的理解？分别应用于哪些场景？" class="headerlink" title="谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？"></a>谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</h5><h5 id="HTTPS-的工作过程？"><a href="#HTTPS-的工作过程？" class="headerlink" title="HTTPS 的工作过程？"></a>HTTPS 的工作过程？</h5><h5 id="HTTP-和-HTTPS-的区别？"><a href="#HTTP-和-HTTPS-的区别？" class="headerlink" title="HTTP 和 HTTPS 的区别？"></a>HTTP 和 HTTPS 的区别？</h5><h5 id="HTTPS-的优缺点？"><a href="#HTTPS-的优缺点？" class="headerlink" title="HTTPS 的优缺点？"></a>HTTPS 的优缺点？</h5><h5 id="什么是数字签名？"><a href="#什么是数字签名？" class="headerlink" title="什么是数字签名？"></a>什么是数字签名？</h5><h5 id="什么是数字证书？"><a href="#什么是数字证书？" class="headerlink" title="什么是数字证书？"></a>什么是数字证书？</h5><h5 id="Cookie-和-Session-有什么区别？"><a href="#Cookie-和-Session-有什么区别？" class="headerlink" title="Cookie 和 Session 有什么区别？"></a>Cookie 和 Session 有什么区别？</h5>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>zhu</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://github.com/sumilk-z/sumilk-z.github.io/2023/03/13/%E5%9B%BE%E8%A7%A3TCPIP%E7%AC%94%E8%AE%B0/">https://github.com/sumilk-z/sumilk-z.github.io/2023/03/13/%E5%9B%BE%E8%A7%A3TCPIP%E7%AC%94%E8%AE%B0/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>LIGHT</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/basic/"># basic</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2023/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/">操作系统相关笔记——进程线程、调度、内存管理、线程调度、锁、IO多路复用</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© zhu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>