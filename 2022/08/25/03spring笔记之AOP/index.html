<!DOCTYPE html>
<html lang="zh-Hans">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="zhu">



    <meta name="description" content="这是一个个人博客">



<title>Spring笔记之AOP | zcblog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Zhu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">主页</a>
                
                    <a class="menu-item" href="/category">归档</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Zhu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">主页</a>
                
                    <a class="menu-item" href="/category">归档</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Spring笔记之AOP</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">zhu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">August 25, 2022&nbsp;&nbsp;23:04:19</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Spring/">Spring</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <blockquote>
<ul>
<li>理解并掌握AOP相关概念</li>
<li>能够说出AOP的工作流程</li>
<li>能够运用AOP相关知识完成对应案例的编写</li>
<li>重点掌握Spring的声明式事务管理</li>
</ul>
</blockquote>
<h3 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h3><h4 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h4><p>AOP(Aspect Oriented Programming) 面向切面编程：一种编程范式，用来指导开发者如何组织程序结构。</p>
<p>类似OOP(Object Oriented Programming) 面向对象编程，都是一种编程思想。</p>
<h4 id="AOP的作用"><a href="#AOP的作用" class="headerlink" title="AOP的作用"></a>AOP的作用</h4><p>在不改变原有代码的基础上进行功能增强。</p>
<h4 id="AOP的核心概念"><a href="#AOP的核心概念" class="headerlink" title="AOP的核心概念"></a>AOP的核心概念</h4><ul>
<li><p>连接点(JoinPoint)</p>
<p>是指程序执行过程中的任意位置。</p>
</li>
<li><p>切入点(Pointcut)</p>
<p>是指需要进行功能增强的连接点。连接点的范围比切入点大，是切入点的方法也一定是连接点。</p>
</li>
<li><p>通知(Advice)</p>
<p>在切入点处执行的操作，也就是共性功能。</p>
</li>
<li><p>通知类</p>
<p>通知的类，因为通知是方法，不能单独存在。</p>
</li>
<li><p>切面(Aspect)</p>
<p>描述通知与切入点的对应关系。</p>
</li>
</ul>
<h3 id="AOP入门案例"><a href="#AOP入门案例" class="headerlink" title="AOP入门案例"></a>AOP入门案例</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>先在pom中导入spring-context依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后定义一个<code>BookDao</code>接口以及其实现类<code>BookDaoImpl</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;bookDao save...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bookDao update...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实现类中，save方法有一个打印当前系统时间的功能，我们希望给update也添加这个功能。</p>
<blockquote>
<p>@Repository 注解表示将BookDaoImpl作为一个Bean交给Spring容器进行管理。</p>
</blockquote>
<p>创建的Spring的配置类 SpringConfig</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Configuration 表明这是一个配置类，@ComponentScan(“com.example”) 表明扫描com.example包下的类，如果有配置为Bean的注解则添加到容器中进行管理。</p>
</blockquote>
<p>然后根据这个配置类启动一个Spring容器并调用BookDao的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line"><span class="comment">//        bookDao.save();</span></span><br><span class="line">        bookDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>因为spring-context中已经导入了spring-aop,所以不需要再单独导入spring-aop</li>
<li>AspectJ是AOP思想的一个具体实现，Spring有自己的AOP实现，但是相比于AspectJ来说比较麻烦。</li>
</ul>
<h4 id="定义通知类和通知"><a href="#定义通知类和通知" class="headerlink" title="定义通知类和通知"></a>定义通知类和通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知就是我们需要增强的功能。</p>
<h4 id="定义切入点"><a href="#定义切入点" class="headerlink" title="定义切入点"></a>定义切入点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"><span class="comment">//    切入点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.example.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>切入点定义依托一个不具有实际意义的方法进行，无参数，无返回值，方法体无具体的逻辑</li>
<li>execution内的内容表明将BookDao.update()方法作为切入点，即增强这个函数。</li>
</ul>
<h4 id="制作切面"><a href="#制作切面" class="headerlink" title="制作切面"></a>制作切面</h4><p>切面是用来描述通知和切入点之间的关系，如何进行关系的绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"><span class="comment">//    切入点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.example.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    切面:切入点和通知的关系</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里表示通知在切入点之前执行。</p>
</blockquote>
<h4 id="将通知类配给容器并表示其为切面类"><a href="#将通知类配给容器并表示其为切面类" class="headerlink" title="将通知类配给容器并表示其为切面类"></a>将通知类配给容器并表示其为切面类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"><span class="comment">//    切入点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.example.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    切面:切入点和通知的关系</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加@Component和@Aspect注解。</p>
</blockquote>
<h4 id="开启注解格式AOP功能"><a href="#开启注解格式AOP功能" class="headerlink" title="开启注解格式AOP功能"></a>开启注解格式AOP功能</h4><p>需要在配置类中开启</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加注解@EnableAspectJAutoProxy</p>
</blockquote>
<h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><p>此时运行程序，在不对BookDao实现类进行更改的情况下为其增强了功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        bookDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1661395606915 // 这个是增强的功能</span><br><span class="line">bookDao update...</span><br></pre></td></tr></table></figure>

<h3 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h3><p>AOP是基于Spring容器管理的bean做的增强，所以从Spring加载bean说起。</p>
<p><strong>容器启动</strong></p>
<p>加载bean:</p>
<ul>
<li>需要被增强的类，如BookDaoImpl</li>
<li>通知类： Advice</li>
<li>此时bean对象还没有创建成功</li>
</ul>
<p><strong>读取所有切面配置中的切入点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"><span class="comment">//    切入点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.example.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.example.dao.BookDao.save())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ptx</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    切面:切入点和通知的关系</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义了两个切入点，但是ptx这个切入点并没有被使用，所以不会被读取。</p>
<p><strong>初始化bean</strong></p>
<p>初始化bean之前判断bean对应的类中的方法是否匹配到任意切入点，例如这里pt所对应的切入点有一个匹配的通知</p>
<p>因此pt所对应的方法<code>com.example.dao.BookDao.update())</code>的类需要被增强<code>com.example.dao.BookDao</code></p>
<p>对于需要被增强的类，创建<strong>代理对象</strong></p>
<p>不需要被增强的类，创建的是<strong>原始对象</strong>。</p>
<blockquote>
<p>这里的代理对象是在原始对象的基础上，可能是采用反射的方法对其增强。 这个叫做动态代理技术。最终运行的是代理对象的方法。</p>
</blockquote>
<ul>
<li>容器在获取bean的时候，需要创建一个对象<ul>
<li>如果目标对象中的方法会被增强（匹配到了切入点），那么容器中将存入的是目标对象的代理对象</li>
<li>如果目标对象中的所有方法都不会被增强（没有任何方法匹配到了切入点），那么容器中存入的就是目标对象本身。</li>
</ul>
</li>
</ul>
<p>两个核心概念</p>
<ul>
<li>目标对象（target）</li>
<li>代理对象（proxy）</li>
</ul>
<h3 id="AOP配置管理"><a href="#AOP配置管理" class="headerlink" title="AOP配置管理"></a>AOP配置管理</h3><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> User com.example.service.UserService.findById(<span class="type">int</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>execution: 动作关键字，描述切入点的行为动作</li>
<li>public: 访问修饰符，可以省略</li>
<li>User 返回类型</li>
<li>com.example.service 包名，多级包使用点连接</li>
<li>UserService: 类或者接口的名称，一般用接口而不是实现类，降低耦合度</li>
<li>findById 方法名</li>
<li>int 参数，直接写参数的类型，多个参数用逗号隔开 (int, String)</li>
<li>异常名： 方法定义中抛出指定异常，可以省略</li>
</ul>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a><strong>通配符</strong></h4><p><code>*</code> 单个独立的任意符号，可以用来表示一级包，或者返回值类型，或者参数类型,或者用来匹配一部分（find*,表示以find开头的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(public * com.example.*.UserService.find*(*))</span><br></pre></td></tr></table></figure>

<p><code>..</code>多个连续的任意符号，常用于简化包名与参数的书写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(public User com..UserService.findById(..))</span><br></pre></td></tr></table></figure>

<p>findById(..) 表示有任意多个参数类型</p>
<p><code>+</code>专用于匹配子类类型，很少用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* *..*Service+.*(..))</span><br></pre></td></tr></table></figure>

<p>一些规范：</p>
<ul>
<li>描述切入点通常描述接口，而不是实现类，降低耦合度。</li>
<li>访问控制修饰符针对接口开发均采用Public描述，可以省略。</li>
<li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配符快速描述。</li>
<li>包名书写尽量不使用<code>..</code>，效率太低，常用<code>*</code>做单个包描述匹配：<code>* com.*.*.*.BookService.findById(int)</code></li>
<li>方法名书写以动词进行精准匹配，名词采用<code>*</code>匹配： <code>getBy*, selectAll*</code></li>
<li>通常不使用异常作为匹配规则。</li>
</ul>
<h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><ul>
<li>前置通知</li>
<li>后置通知</li>
<li>环绕通知（重点）</li>
<li>返回后通知（了解）</li>
<li>抛出异常后通知（了解）</li>
</ul>
<p><img src="/assets/image-20220825200107604.png" alt="image-20220825200107604"></p>
<p><strong>before和after类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.advice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"><span class="comment">//    切入点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.example.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行update()方法，得到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before...</span><br><span class="line">bookDao update...</span><br><span class="line">after...</span><br></pre></td></tr></table></figure>

<p><strong>around</strong></p>
<p>如果是around类型的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切入点</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.example.dao.BookDao.update())&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切面：切入点和通知的关系</span></span><br><span class="line"><span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;around before...&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里相当于执行update()函数。</span></span><br><span class="line">    <span class="comment">// 如果有返回值需要接收返回值，例如 int res = (int)pjp.processed(),然后return res;</span></span><br><span class="line">    pjp.proceed(); </span><br><span class="line">    System.out.println(<span class="string">&quot;around after...&quot;</span>);</span><br><span class="line">    <span class="comment">// return res;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行update函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">around before...</span><br><span class="line">bookDao update...</span><br><span class="line">around after...</span><br></pre></td></tr></table></figure>

<p><strong>afterReturning</strong></p>
<p>其余两种类型，例如afterReturning，假设定义了一个新的方法有返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;select...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个新的切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(int com.example.dao.BookDao.select())&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ptx</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这里的返回值类型为int否则无法匹配成功</p>
</blockquote>
<p>设置一个新的切面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(&quot;ptx()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;after returning...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行select()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> bookDao.select();</span><br><span class="line">System.out.println(select);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select...</span><br><span class="line">after returning...</span><br><span class="line">1 // 这个1是输出的结果</span><br></pre></td></tr></table></figure>



<blockquote>
<p>返回后通知在原始方法正常执行后才会被执行，如果执行过程中出现了异常，则不会被执行该通知； 而after通知不管执行有没有抛出异常，都会正常执行该通知。</p>
</blockquote>
<p>如果人为设置一个异常，则不会执行 afterReturning通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;select...&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>; <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select...</span><br><span class="line">...省略一堆爆红异常</span><br></pre></td></tr></table></figure>

<p><strong>afterThrowing</strong></p>
<p>而如果配置了一个<code>afterThrowing</code>通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(int com.example.dao.BookDao.select())&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ptx</span><span class="params">()</span>&#123;&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterThrowing(&quot;ptx()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;after throwing...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再执行select方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select...</span><br><span class="line">after throwing...</span><br><span class="line">...省略一堆爆红异常</span><br></pre></td></tr></table></figure>

<p><strong>最后</strong></p>
<p>因为环绕通知是可以控制原始方法执行的，所以把增强的代码写在调用方法的不同位置就可以实现不同的通知类型的功能，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">method</span><span class="params">(ProceedingJointPoint pjp)</span>&#123;</span><br><span class="line">        <span class="comment">// 代码1 前置通知</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 代码2 前置通知</span></span><br><span class="line">            ret = pjp.proceed(); <span class="comment">// 调用原始方法，返回类型是Object，如果需要别的操作可以做强制类型转换再操作</span></span><br><span class="line">            <span class="comment">// 代码3： 返回后通知</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            <span class="comment">// 代码4： afterThrowing 通知</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代码5 后置通知</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>环绕通知注意事项</strong></p>
<ol>
<li>环绕通知必须依赖形参ProceedingJointPoint才能实现对原始方法的调用</li>
<li>通知中如果没有调用原始方法将跳过原始方法的执行</li>
<li>对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收，最好设置成Object类型</li>
<li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须处理Throwable异常</li>
</ol>
<p>假设给select方法配置了以下通知类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;ptx()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;around before...&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    System.out.println(<span class="string">&quot;around after...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)res+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterReturning(&quot;ptx()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;after returning...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行并输出select的返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;select...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">around before...</span><br><span class="line">select...</span><br><span class="line">after returning...</span><br><span class="line">around after...</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<h4 id="通知中获取参数"><a href="#通知中获取参数" class="headerlink" title="通知中获取参数"></a>通知中获取参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJointPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">    Object[] args = pjp.getArgs();</span><br><span class="line">    args[<span class="number">0</span>] = <span class="number">666</span>; <span class="comment">// 取出参数修改后再放回执行，可以用来过滤不合适的参数。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(args);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非环绕类型的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JointPoint jp)</span>&#123;</span><br><span class="line">    Object[] args = jp.getArgs();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JointPoint 这个只能用来获取参数，不能用来执行原来的方法，因为原来的方法不像around，其执行的位置是确定的。</p>
</blockquote>
<blockquote>
<p>而around通知类型，需要给用户权力确定原来的方法该在哪里执行。</p>
</blockquote>
<h3 id="AOP事务管理"><a href="#AOP事务管理" class="headerlink" title="AOP事务管理"></a>AOP事务管理</h3><p>数据库中事务的作用：在数据层保障一系列的数据库操作同步成功或者失败</p>
<p>而Spring中事务的作用：在数据层或业务层保障一系列的数据库操作同步成功或者失败；</p>
<blockquote>
<p>实际上是将数据库的事务统一起来，形成一个大的事务，该事务控制小的事务统一成功或者失败。</p>
</blockquote>
<p>例如：转账业务会有两次数据层的调用，一次加，一次减。这就是两个事务，需要一个大的事务来统一这两个事务同时成功或者失败。</p>
<p>Spring提供了一个事务管理器的接口<code>PlatformTransactionManager</code>和一个实现<code>DataSourceTransactionManager</code></p>
<p>只需要给它一个DataSource对象，就可以帮助在业务层管理事务，内部采用的是JDBC的事务。</p>
<blockquote>
<p>JDBC的事务：数据层的事务，数据库的事务。</p>
<p>Spring的事务： 业务层的事务，管理数据层事务的大事务。（小太监和内务总管）</p>
</blockquote>
<p>配置事务管理器,在JDBC的配置类中进行配置即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    transactionManager.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> transactionManager</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再SpringConfig总配置中开启该功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionmanagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在实现类或者实现类的具体方法上添加注解，表示开启事务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out, String in, Double money)</span>&#123;</span><br><span class="line">    accountDao.outmoney(out,money);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>/<span class="number">0</span>; <span class="comment">// 这样即便出现异常，这个函数也会整体成功或者失败，已经执行的部分会进行事务的回滚</span></span><br><span class="line">    accountDao.inmoney(in,money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>zhu</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://github.com/sumilk-z/sumilk-z.github.io/2022/08/25/03spring%E7%AC%94%E8%AE%B0%E4%B9%8BAOP/">https://github.com/sumilk-z/sumilk-z.github.io/2022/08/25/03spring%E7%AC%94%E8%AE%B0%E4%B9%8BAOP/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>LIGHT</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Java/"># Java</a>
                    
                        <a href="/tags/%E5%90%8E%E7%AB%AF/"># 后端</a>
                    
                        <a href="/tags/Spring/"># Spring</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2022/08/24/02.JavaWeb%E4%B9%8BMyBatis/">02JavaWeb之MyBatis</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© zhu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>